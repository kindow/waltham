<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Waltham: server-api-example.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Waltham
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">server-api-example.c</div>  </div>
</div><!--header-->
<div class="contents">
<p>An example of a server that can handle multiple clients concurrently.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright Â© 2016 DENSO CORPORATION</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</span></div><div class="line"><span class="comment"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span></div><div class="line"><span class="comment"> * to deal in the Software without restriction, including without limitation</span></div><div class="line"><span class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span></div><div class="line"><span class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</span></div><div class="line"><span class="comment"> * Software is furnished to do so, subject to the following conditions:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The above copyright notice and this permission notice (including the next</span></div><div class="line"><span class="comment"> * paragraph) shall be included in all copies or substantial portions of the</span></div><div class="line"><span class="comment"> * Software.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></div><div class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></div><div class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span></div><div class="line"><span class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></div><div class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></div><div class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span></div><div class="line"><span class="comment"> * DEALINGS IN THE SOFTWARE.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/epoll.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/types.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;netinet/in.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="waltham-object_8h.html">waltham-object.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;waltham-server.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="waltham-connection_8h.html">waltham-connection.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;w-util.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MAX_EPOLL_WATCHES 2</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>server;</div><div class="line"><span class="keyword">struct </span>client;</div><div class="line"></div><div class="line"><span class="comment">/* epoll structure */</span></div><div class="line"><span class="keyword">struct </span>watch {</div><div class="line">        <span class="keyword">struct </span>server *server;</div><div class="line">        <span class="keywordtype">int</span> fd;</div><div class="line">        void (*cb)(<span class="keyword">struct </span>watch *w, uint32_t events);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* wthp_region protocol object */</span></div><div class="line"><span class="keyword">struct </span>region {</div><div class="line">        <span class="keyword">struct </span>wthp_region *obj;</div><div class="line">        <span class="comment">/* pixman_region32_t region; */</span></div><div class="line">        <span class="keyword">struct </span>wl_list link; <span class="comment">/* struct client::region_list */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* wthp_compositor protocol object */</span></div><div class="line"><span class="keyword">struct </span>compositor {</div><div class="line">        <span class="keyword">struct </span>wthp_compositor *obj;</div><div class="line">        <span class="keyword">struct </span>client *client;</div><div class="line">        <span class="keyword">struct </span>wl_list link; <span class="comment">/* struct client::compositor_list */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* wthp_registry protocol object */</span></div><div class="line"><span class="keyword">struct </span>registry {</div><div class="line">        <span class="keyword">struct </span>wthp_registry *obj;</div><div class="line">        <span class="keyword">struct </span>client *client;</div><div class="line">        <span class="keyword">struct </span>wl_list link; <span class="comment">/* struct client::registry_list */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>client {</div><div class="line">        <span class="keyword">struct </span>wl_list link; <span class="comment">/* struct server::client_list */</span></div><div class="line">        <span class="keyword">struct </span>server *server;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span><a name="_a0"></a><a class="code" href="classwth__connection.html">wth_connection</a> *connection;</div><div class="line">        <span class="keyword">struct </span>watch conn_watch;</div><div class="line"></div><div class="line">        <span class="comment">/* client object lists for clean-up on disconnection */</span></div><div class="line">        <span class="keyword">struct </span>wl_list registry_list;   <span class="comment">/* struct registry::link */</span></div><div class="line">        <span class="keyword">struct </span>wl_list compositor_list; <span class="comment">/* struct compositor::link */</span></div><div class="line">        <span class="keyword">struct </span>wl_list region_list;     <span class="comment">/* struct region::link */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>server {</div><div class="line">        <span class="keywordtype">int</span> listen_fd;</div><div class="line">        <span class="keyword">struct </span>watch listen_watch;</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> running;</div><div class="line">        <span class="keywordtype">int</span> epoll_fd;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>wl_list client_list; <span class="comment">/* struct client::link */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span></div><div class="line">watch_ctl(<span class="keyword">struct</span> watch *w, <span class="keywordtype">int</span> op, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>epoll_event ee;</div><div class="line"></div><div class="line">        ee.events = events;</div><div class="line">        ee.data.ptr = w;</div><div class="line">        <span class="keywordflow">return</span> epoll_ctl(w-&gt;server-&gt;epoll_fd, op, w-&gt;fd, &amp;ee);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* BEGIN wthp_region implementation */</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">region_destroy(<span class="keyword">struct</span> region *region)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;region %p destroy\n&quot;</span>, region-&gt;obj);</div><div class="line"></div><div class="line">        wthp_region_free(region-&gt;obj);</div><div class="line">        wl_list_remove(&amp;region-&gt;link);</div><div class="line">        free(region);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">region_handle_destroy(<span class="keyword">struct</span> wthp_region *wthp_region)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>region *region = wth_object_get_user_data((<span class="keyword">struct</span> <a name="_a1"></a><a class="code" href="classwth__object.html">wth_object</a> *)wthp_region);</div><div class="line"></div><div class="line">        assert(wthp_region == region-&gt;obj);</div><div class="line"></div><div class="line">        region_destroy(region);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">region_handle_add(<span class="keyword">struct</span> wthp_region *wthp_region,</div><div class="line">                  int32_t x, int32_t y, int32_t width, int32_t height)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;region %p add(%d, %d, %d, %d)\n&quot;</span>,</div><div class="line">                wthp_region, x, y, width, height);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">region_handle_subtract(<span class="keyword">struct</span> wthp_region *wthp_region,</div><div class="line">                       int32_t x, int32_t y,</div><div class="line">                       int32_t width, int32_t height)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;region %p subtract(%d, %d, %d, %d)\n&quot;</span>,</div><div class="line">                wthp_region, x, y, width, height);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a name="_a2"></a><a class="code" href="structwthp__region__interface.html">wthp_region_interface</a> region_implementation = {</div><div class="line">        region_handle_destroy,</div><div class="line">        region_handle_add,</div><div class="line">        region_handle_subtract</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* END wthp_region implementation */</span></div><div class="line"></div><div class="line"><span class="comment">/* BEGIN wthp_compositor implementation */</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">compositor_destroy(<span class="keyword">struct</span> compositor *comp)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;%s: %p\n&quot;</span>, __func__, comp-&gt;obj);</div><div class="line"></div><div class="line">        wthp_compositor_free(comp-&gt;obj);</div><div class="line">        wl_list_remove(&amp;comp-&gt;link);</div><div class="line">        free(comp);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">compositor_handle_create_surface(<span class="keyword">struct</span> wthp_compositor *compositor,</div><div class="line">                                 <span class="keyword">struct</span> wthp_surface *<span class="keywordtype">id</span>)</div><div class="line">{</div><div class="line">        wth_object_post_error((<span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *)compositor, 0,</div><div class="line">                              <span class="stringliteral">&quot;unimplemented: %s&quot;</span>, __func__);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">compositor_handle_create_region(<span class="keyword">struct</span> wthp_compositor *compositor,</div><div class="line">                                <span class="keyword">struct</span> wthp_region *<span class="keywordtype">id</span>)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>compositor *comp = wth_object_get_user_data((<span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *)compositor);</div><div class="line">        <span class="keyword">struct </span>region *region;</div><div class="line"></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;client %p create region %p\n&quot;</span>,</div><div class="line">                comp-&gt;client, <span class="keywordtype">id</span>);</div><div class="line"></div><div class="line">        region = zalloc(<span class="keyword">sizeof</span> *region);</div><div class="line">        <span class="keywordflow">if</span> (!region) {</div><div class="line">                wth_connection_post_error_no_memory(comp-&gt;client-&gt;connection);</div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        region-&gt;obj = id;</div><div class="line">        wl_list_insert(&amp;comp-&gt;client-&gt;region_list, &amp;region-&gt;link);</div><div class="line"></div><div class="line">        wthp_region_set_interface(<span class="keywordtype">id</span>, &amp;region_implementation, region);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a name="_a3"></a><a class="code" href="structwthp__compositor__interface.html">wthp_compositor_interface</a> compositor_implementation = {</div><div class="line">        compositor_handle_create_surface,</div><div class="line">        compositor_handle_create_region</div><div class="line">        <span class="comment">/* XXX: protocol is missing destructor */</span></div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">client_bind_compositor(<span class="keyword">struct</span> client *c, <span class="keyword">struct</span> wthp_compositor *obj)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>compositor *comp;</div><div class="line"></div><div class="line">        comp = zalloc(<span class="keyword">sizeof</span> *comp);</div><div class="line">        <span class="keywordflow">if</span> (!comp) {</div><div class="line">                wth_connection_post_error_no_memory(c-&gt;connection);</div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        comp-&gt;obj = obj;</div><div class="line">        comp-&gt;client = c;</div><div class="line">        wl_list_insert(&amp;c-&gt;compositor_list, &amp;comp-&gt;link);</div><div class="line"></div><div class="line">        wthp_compositor_set_interface(obj, &amp;compositor_implementation,</div><div class="line">                                      comp);</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;client %p bound wthp_compositor\n&quot;</span>, c);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* END wthp_compositor implementation */</span></div><div class="line"></div><div class="line"><span class="comment">/* BEGIN wthp_registry implementation */</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">registry_destroy(<span class="keyword">struct</span> registry *reg)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;%s: %p\n&quot;</span>, __func__, reg-&gt;obj);</div><div class="line"></div><div class="line">        wthp_registry_free(reg-&gt;obj);</div><div class="line">        wl_list_remove(&amp;reg-&gt;link);</div><div class="line">        free(reg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">registry_handle_destroy(<span class="keyword">struct</span> wthp_registry *registry)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>registry *reg = wth_object_get_user_data((<span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *)registry);</div><div class="line"></div><div class="line">        registry_destroy(reg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">registry_handle_bind(<span class="keyword">struct</span> wthp_registry *registry,</div><div class="line">                     uint32_t name,</div><div class="line">                     <span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *<span class="keywordtype">id</span>,</div><div class="line">                     <span class="keyword">const</span> <span class="keywordtype">char</span> *interface,</div><div class="line">                     uint32_t version)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>registry *reg = wth_object_get_user_data((<span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *)registry);</div><div class="line"></div><div class="line">        <span class="comment">/* XXX: we could use a database of globals instead of hardcoding them */</span></div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (strcmp(interface, <span class="stringliteral">&quot;wthp_compositor&quot;</span>) == 0) {</div><div class="line">                <span class="comment">/* XXX: check version against limits */</span></div><div class="line">                <span class="comment">/* XXX: check that name and interface match */</span></div><div class="line">                client_bind_compositor(reg-&gt;client, (<span class="keyword">struct</span> wthp_compositor *)<span class="keywordtype">id</span>);</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                wth_object_post_error((<span class="keyword">struct</span> <a class="code" href="classwth__object.html">wth_object</a> *)registry, 0,</div><div class="line">                                      <span class="stringliteral">&quot;%s: unknown name %u&quot;</span>, __func__, name);</div><div class="line">                wth_object_delete(<span class="keywordtype">id</span>);</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">struct </span><a name="_a4"></a><a class="code" href="structwthp__registry__interface.html">wthp_registry_interface</a> registry_implementation = {</div><div class="line">        registry_handle_destroy,</div><div class="line">        registry_handle_bind</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* END wthp_registry implementation */</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">display_handle_get_registry(<span class="keyword">struct</span> wthp_registry *registry,</div><div class="line">                            <span class="keywordtype">void</span> *user_pointer)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>client *c = (<span class="keyword">struct </span>client *)user_pointer;</div><div class="line">        <span class="keyword">struct </span>registry *reg;</div><div class="line"></div><div class="line">        reg = zalloc(<span class="keyword">sizeof</span> *reg);</div><div class="line">        <span class="keywordflow">if</span> (!reg) {</div><div class="line">                wth_connection_post_error_no_memory(c-&gt;connection);</div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        reg-&gt;obj = registry;</div><div class="line">        reg-&gt;client = c;</div><div class="line">        wl_list_insert(&amp;c-&gt;registry_list, &amp;reg-&gt;link);</div><div class="line">        wthp_registry_set_interface(registry,</div><div class="line">                                    &amp;registry_implementation, reg);</div><div class="line"></div><div class="line">        <span class="comment">/* XXX: advertise our globals */</span></div><div class="line">        wthp_registry_send_global(registry, 1, <span class="stringliteral">&quot;wthp_compositor&quot;</span>, 4);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">client_destroy(<span class="keyword">struct</span> client *c)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>region *region;</div><div class="line">        <span class="keyword">struct </span>compositor *comp;</div><div class="line">        <span class="keyword">struct </span>registry *reg;</div><div class="line"></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Client %p disconnected.\n&quot;</span>, c);</div><div class="line"></div><div class="line">        <span class="comment">/* clean up remaining client resources in case the client</span></div><div class="line"><span class="comment">         * did not.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        wl_list_last_until_empty(region, &amp;c-&gt;region_list, link)</div><div class="line">                region_destroy(region);</div><div class="line"></div><div class="line">        wl_list_last_until_empty(comp, &amp;c-&gt;compositor_list, link)</div><div class="line">                compositor_destroy(comp);</div><div class="line"></div><div class="line">        wl_list_last_until_empty(reg, &amp;c-&gt;registry_list, link)</div><div class="line">                registry_destroy(reg);</div><div class="line"></div><div class="line">        wl_list_remove(&amp;c-&gt;link);</div><div class="line">        watch_ctl(&amp;c-&gt;conn_watch, EPOLL_CTL_DEL, 0);</div><div class="line">        wth_connection_destroy(c-&gt;connection);</div><div class="line">        free(c);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">connection_handle_data(<span class="keyword">struct</span> watch *w, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>client *c = container_of(w, <span class="keyword">struct</span> client, conn_watch);</div><div class="line">        <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLERR) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Client %p errored out.\n&quot;</span>, c);</div><div class="line">                client_destroy(c);</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLHUP) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Client %p hung up.\n&quot;</span>, c);</div><div class="line">                client_destroy(c);</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLOUT) {</div><div class="line">                ret = wth_connection_flush(c-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret == 0)</div><div class="line">                        watch_ctl(&amp;c-&gt;conn_watch, EPOLL_CTL_MOD, EPOLLIN);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; errno != EAGAIN){</div><div class="line">                        fprintf(stderr, <span class="stringliteral">&quot;Client %p flush error.\n&quot;</span>, c);</div><div class="line">                        client_destroy(c);</div><div class="line"></div><div class="line">                        <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLIN) {</div><div class="line">                ret = wth_connection_read(c-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">                        fprintf(stderr, <span class="stringliteral">&quot;Client %p read error.\n&quot;</span>, c);</div><div class="line">                        client_destroy(c);</div><div class="line"></div><div class="line">                        <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                ret = wth_connection_dispatch(c-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; errno != EPROTO) {</div><div class="line">                        fprintf(stderr, <span class="stringliteral">&quot;Client %p dispatch error.\n&quot;</span>, c);</div><div class="line">                        client_destroy(c);</div><div class="line"></div><div class="line">                        <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>client *</div><div class="line">client_create(<span class="keyword">struct</span> server *srv, <span class="keyword">struct</span> <a class="code" href="classwth__connection.html">wth_connection</a> *conn)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>client *c;</div><div class="line"></div><div class="line">        c = zalloc(<span class="keyword">sizeof</span> *c);</div><div class="line">        <span class="keywordflow">if</span> (!c)</div><div class="line">                <span class="keywordflow">return</span> NULL;</div><div class="line"></div><div class="line">        c-&gt;server = srv;</div><div class="line">        c-&gt;connection = conn;</div><div class="line"></div><div class="line">        c-&gt;conn_watch.server = srv;</div><div class="line">        c-&gt;conn_watch.fd = wth_connection_get_fd(conn);</div><div class="line">        c-&gt;conn_watch.cb = connection_handle_data;</div><div class="line">        <span class="keywordflow">if</span> (watch_ctl(&amp;c-&gt;conn_watch, EPOLL_CTL_ADD, EPOLLIN) &lt; 0) {</div><div class="line">                free(c);</div><div class="line">                <span class="keywordflow">return</span> NULL;</div><div class="line">        }</div><div class="line"></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Client %p connected.\n&quot;</span>, c);</div><div class="line"></div><div class="line">        wl_list_insert(&amp;srv-&gt;client_list, &amp;c-&gt;link);</div><div class="line"></div><div class="line">        wl_list_init(&amp;c-&gt;registry_list);</div><div class="line">        wl_list_init(&amp;c-&gt;compositor_list);</div><div class="line">        wl_list_init(&amp;c-&gt;region_list);</div><div class="line"></div><div class="line">        wth_connection_set_registry_callback(conn, display_handle_get_registry, c);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> c;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">server_flush_clients(<span class="keyword">struct</span> server *srv)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>client *c, *tmp;</div><div class="line">        <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">        wl_list_for_each_safe(c, tmp, &amp;srv-&gt;client_list, link) {</div><div class="line">                <span class="comment">/* Flush out buffered requests. If the Waltham socket is</span></div><div class="line"><span class="comment">                 * full, poll it for writable too.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                ret = wth_connection_flush(c-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; errno == EAGAIN) {</div><div class="line">                        watch_ctl(&amp;c-&gt;conn_watch, EPOLL_CTL_MOD, EPOLLIN | EPOLLOUT);</div><div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">                        perror(<span class="stringliteral">&quot;Connection flush failed&quot;</span>);</div><div class="line">                        client_destroy(c);</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">server_accept_client(<span class="keyword">struct</span> server *srv)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>client *client;</div><div class="line">        <span class="keyword">struct </span><a class="code" href="classwth__connection.html">wth_connection</a> *conn;</div><div class="line">        <span class="keyword">struct </span>sockaddr_in addr;</div><div class="line">        socklen_t len;</div><div class="line"></div><div class="line">        len = <span class="keyword">sizeof</span> addr;</div><div class="line">        conn = wth_accept(srv-&gt;listen_fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, &amp;len);</div><div class="line">        <span class="keywordflow">if</span> (!conn) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Failed to accept a connection.\n&quot;</span>);</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        client = client_create(srv, conn);</div><div class="line">        <span class="keywordflow">if</span> (!client) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Failed client_create().\n&quot;</span>);</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">listen_socket_handle_data(<span class="keyword">struct</span> watch *w, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>server *srv = container_of(w, <span class="keyword">struct</span> server, listen_watch);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLERR) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Listening socket errored out.\n&quot;</span>);</div><div class="line">                srv-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLHUP) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Listening socket hung up.\n&quot;</span>);</div><div class="line">                srv-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLIN)</div><div class="line">                server_accept_client(srv);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">mainloop(<span class="keyword">struct</span> server *srv)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>epoll_event ee[MAX_EPOLL_WATCHES];</div><div class="line">        <span class="keyword">struct </span>watch *w;</div><div class="line">        <span class="keywordtype">int</span> count;</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line"></div><div class="line">        srv-&gt;running = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (srv-&gt;running) {</div><div class="line">                <span class="comment">/* Run any idle tasks at this point. */</span></div><div class="line"></div><div class="line">                server_flush_clients(srv);</div><div class="line"></div><div class="line">                <span class="comment">/* Wait for events or signals */</span></div><div class="line">                count = epoll_wait(srv-&gt;epoll_fd,</div><div class="line">                                   ee, ARRAY_LENGTH(ee), -1);</div><div class="line">                <span class="keywordflow">if</span> (count &lt; 0 &amp;&amp; errno != EINTR) {</div><div class="line">                        perror(<span class="stringliteral">&quot;Error with epoll_wait&quot;</span>);</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Handle all fds, both the listening socket</span></div><div class="line"><span class="comment">                 * (see listen_socket_handle_data()) and clients</span></div><div class="line"><span class="comment">                 * (see connection_handle_data()).</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {</div><div class="line">                        w = ee[i].data.ptr;</div><div class="line">                        w-&gt;cb(w, ee[i].events);</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span></div><div class="line">server_listen(uint16_t tcp_port)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> fd;</div><div class="line">        <span class="keywordtype">int</span> reuse = 1;</div><div class="line">        <span class="keyword">struct </span>sockaddr_in addr;</div><div class="line"></div><div class="line">        fd = socket(AF_INET, SOCK_STREAM, 0);</div><div class="line"></div><div class="line">        memset(&amp;addr, 0, <span class="keyword">sizeof</span>(addr));</div><div class="line">        addr.sin_family = AF_INET;</div><div class="line">        addr.sin_port = htons(tcp_port);</div><div class="line">        addr.sin_addr.s_addr = htonl(INADDR_ANY);</div><div class="line"></div><div class="line">        setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span> reuse);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (bind(fd, (<span class="keyword">struct</span> sockaddr *)&amp;addr, <span class="keyword">sizeof</span> addr) &lt; 0) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Failed to bind to port %d&quot;</span>, tcp_port);</div><div class="line">                close(fd);</div><div class="line">                <span class="keywordflow">return</span> -1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (listen(fd, 1024) &lt; 0) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Failed to listen to port %d&quot;</span>, tcp_port);</div><div class="line">                close (fd);</div><div class="line">                <span class="keywordflow">return</span> -1;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> fd;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> *signal_int_handler_run_flag;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">signal_int_handler(<span class="keywordtype">int</span> signum)</div><div class="line">{</div><div class="line">        <span class="keywordflow">if</span> (!*signal_int_handler_run_flag)</div><div class="line">                abort();</div><div class="line"></div><div class="line">        *signal_int_handler_run_flag = <span class="keyword">false</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">set_sigint_handler(<span class="keywordtype">bool</span> *running)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>sigaction sigint;</div><div class="line"></div><div class="line">        signal_int_handler_run_flag = running;</div><div class="line">        sigint.sa_handler = signal_int_handler;</div><div class="line">        sigemptyset(&amp;sigint.sa_mask);</div><div class="line">        sigint.sa_flags = SA_RESETHAND;</div><div class="line">        sigaction(SIGINT, &amp;sigint, NULL);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main(<span class="keywordtype">int</span> arcg, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>server srv = { 0 };</div><div class="line">        <span class="keyword">struct </span>client *c;</div><div class="line">        uint16_t tcp_port = 34400;</div><div class="line"></div><div class="line">        set_sigint_handler(&amp;srv.running);</div><div class="line"></div><div class="line">        wl_list_init(&amp;srv.client_list);</div><div class="line"></div><div class="line">        srv.epoll_fd = epoll_create1(EPOLL_CLOEXEC);</div><div class="line">        <span class="keywordflow">if</span> (srv.epoll_fd == -1) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error on epoll_create1&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        srv.listen_fd = server_listen(tcp_port);</div><div class="line">        <span class="keywordflow">if</span> (srv.listen_fd &lt; 0) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error setting up listening socket&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        srv.listen_watch.server = &amp;srv;</div><div class="line">        srv.listen_watch.cb = listen_socket_handle_data;</div><div class="line">        srv.listen_watch.fd = srv.listen_fd;</div><div class="line">        <span class="keywordflow">if</span> (watch_ctl(&amp;srv.listen_watch, EPOLL_CTL_ADD, EPOLLIN) &lt; 0) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error setting up listen polling&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        printf(<span class="stringliteral">&quot;Waltham server listening on TCP port %u...\n&quot;</span>,</div><div class="line">               tcp_port);</div><div class="line"></div><div class="line">        mainloop(&amp;srv);</div><div class="line"></div><div class="line">        <span class="comment">/* destroy all things */</span></div><div class="line">        wl_list_last_until_empty(c, &amp;srv.client_list, link)</div><div class="line">                client_destroy(c);</div><div class="line"></div><div class="line">        close(srv.listen_fd);</div><div class="line">        close(srv.epoll_fd);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
