Waltham
=======

Waltham is a network IPC library designed to resemble Wayland both
protocol and protocol-API wise.

Waltham does not (yet) support any kind of encryption, so usage in
untrusted networks is not advised.

Protocol is described in XML files. The generator translates XML into C
code.

Waltham ABI and API are not yet stable. Breakage will likely occur.


Building and testing
====================

Waltham depends on glib, but this dependency is to be removed.

To build:
$ ./autogen.sh
$ make

To test, first start the server:
$ ./tests/server

Then in another terminal, run the client:
$ ./tests/client

The client does a wth_display.sync, waits for the answer, and exits.

The server can be stopped with ctrl+c.

The client can be run repeatedly, but currently running several clients
at the same time is not supported. See TODO for more unfinished items.


Design
======

The Waltham API revolves around two fundamental types: wth_connection
and wth_object. The both have the same implementation on both server
and client side, although the possible operations (functions to call)
vary. Once created, both types are tied to being either server or
client side instances.

wth_connection represents the TCP connection. For a client it
represents the connection to a server, for a server it represents one
client.

wth_object represents a protocol object. However, usually user code
does not handle wth_objects directly, but works with the API generated
from XML files which uses opaque pointer types. These opaque pointer
types are simply cast to/from wth_object under the hood.

Waltham does not carry features to help making threaded programs
easier. However, it should be safe if you restrict all manipulations of
a wth_connection and all wth_objects associated with it to a single
thread at a time.

Incoming messages, both on the server and client side, are first stored
in a raw data buffer. Messages are dispatched directly from the data
buffer. This is different from Wayland, which demarshals messages from
its data buffer and puts them into queues before dispatching per queue.
The additional queueing in Wayland adds some complexity that Waltham
avoids.

Waltham does not include any automatic object destruction when a
wth_connection is destroyed. User code must track and destroy all
associated wth_objects before destroying the wth_connection. This may
seem awkward at first, but it gives the user code the opportunity to
destroy wth_objects in any specific order it prefers and without the
risk of corrupting lists. Compare this to Wayland, where one has to be
able to deal with any arbitrary order of destruction between all
wl_resources, and the destructor path of one wl_resource cannot remove
any other destroy listeners that might be on the same destroy listener
list as that would lead to list corruption.

wth_object instances are created automatically during dispatch, which
means that messages not yet dispatched have not created any entries in
the table that maps between object IDs on the wire and wth_object
instances. Therefore objects do not need to be cleaned up until the
messages creating them have been dispatched, so there is no need for
destructor hooks in wth_object.
