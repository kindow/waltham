<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Waltham: client-api-example.c</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Waltham
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">client-api-example.c</div>  </div>
</div><!--header-->
<div class="contents">
<p>An example of a client that connects to a server and excercises some of the protocol requests.</p>
<div class="fragment"><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Copyright Â© 2016 DENSO CORPORATION</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * Permission is hereby granted, free of charge, to any person obtaining a</span></div><div class="line"><span class="comment"> * copy of this software and associated documentation files (the &quot;Software&quot;),</span></div><div class="line"><span class="comment"> * to deal in the Software without restriction, including without limitation</span></div><div class="line"><span class="comment"> * the rights to use, copy, modify, merge, publish, distribute, sublicense,</span></div><div class="line"><span class="comment"> * and/or sell copies of the Software, and to permit persons to whom the</span></div><div class="line"><span class="comment"> * Software is furnished to do so, subject to the following conditions:</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * The above copyright notice and this permission notice (including the next</span></div><div class="line"><span class="comment"> * paragraph) shall be included in all copies or substantial portions of the</span></div><div class="line"><span class="comment"> * Software.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span></div><div class="line"><span class="comment"> * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span></div><div class="line"><span class="comment"> * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL</span></div><div class="line"><span class="comment"> * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span></div><div class="line"><span class="comment"> * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING</span></div><div class="line"><span class="comment"> * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER</span></div><div class="line"><span class="comment"> * DEALINGS IN THE SOFTWARE.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;assert.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;errno.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdbool.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdio.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;stdlib.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;string.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/epoll.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/socket.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/timerfd.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;sys/types.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;unistd.h&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="waltham-object_8h.html">waltham-object.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;waltham-client.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="waltham-connection_8h.html">waltham-connection.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;w-util.h&quot;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#define MAX_EPOLL_WATCHES 2</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>display;</div><div class="line"></div><div class="line"><span class="comment">/* epoll structure */</span></div><div class="line"><span class="keyword">struct </span>watch {</div><div class="line">        <span class="keyword">struct </span>display *display;</div><div class="line">        <span class="keywordtype">int</span> fd;</div><div class="line">        void (*cb)(<span class="keyword">struct </span>watch *w, uint32_t events);</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">struct </span>display {</div><div class="line">        <span class="keyword">struct </span><a name="_a0"></a><a class="code" href="classwth__connection.html">wth_connection</a> *connection;</div><div class="line">        <span class="keyword">struct </span>watch conn_watch;</div><div class="line"></div><div class="line">        <span class="keywordtype">bool</span> running;</div><div class="line">        <span class="keywordtype">int</span> epoll_fd;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>wthp_registry *registry;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>wthp_callback *bling;</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>wthp_compositor *compositor;</div><div class="line">        <span class="keyword">struct </span>wtimer *fiddle_timer;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* a timerfd based timer */</span></div><div class="line"><span class="keyword">struct </span>wtimer {</div><div class="line">        <span class="keyword">struct </span>watch watch;</div><div class="line">        void (*func)(<span class="keyword">struct </span>wtimer *, <span class="keywordtype">void</span> *);</div><div class="line">        <span class="keywordtype">void</span> *data;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">/* Have some fun with a wthp_region, just to excercise the protocol. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">fiddle_with_region(<span class="keyword">struct</span> display *dpy)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>wthp_region *region;</div><div class="line"></div><div class="line">        region = wthp_compositor_create_region(dpy-&gt;compositor);</div><div class="line"></div><div class="line">        wthp_region_add(region, 2, 2, 10, 10);</div><div class="line">        wthp_region_add(region, 12, 2, 100, 50);</div><div class="line">        wthp_region_subtract(region, 50, 50, 5, 5);</div><div class="line"></div><div class="line">        wthp_region_destroy(region);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* The server advertises a global interface.</span></div><div class="line"><span class="comment"> * We can store the ad for later and/or bind to it immediately</span></div><div class="line"><span class="comment"> * if we want to.</span></div><div class="line"><span class="comment"> * We also need to keep track of the globals we bind to, so that</span></div><div class="line"><span class="comment"> * global_remove can be handled properly (not implemented).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">registry_handle_global(<span class="keyword">struct</span> wthp_registry *registry,</div><div class="line">                       uint32_t name,</div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">char</span> *interface,</div><div class="line">                       uint32_t version)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>display *dpy = wth_object_get_user_data((<span class="keyword">struct</span> <a name="_a1"></a><a class="code" href="classwth__object.html">wth_object</a> *)registry);</div><div class="line"></div><div class="line">        printf(<span class="stringliteral">&quot;got global %d: &#39;%s&#39; version &#39;%d&#39;\n&quot;</span>,</div><div class="line">               name, interface, version);</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (strcmp(interface, <span class="stringliteral">&quot;wthp_compositor&quot;</span>) == 0) {</div><div class="line">                assert(!dpy-&gt;compositor);</div><div class="line">                dpy-&gt;compositor = (<span class="keyword">struct </span>wthp_compositor *)wthp_registry_bind(registry, name, interface, 1);</div><div class="line">                <span class="comment">/* has no events to handle */</span></div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* The server removed a global.</span></div><div class="line"><span class="comment"> * We should destroy everything we created through that global,</span></div><div class="line"><span class="comment"> * and destroy the objects we created by binding to it.</span></div><div class="line"><span class="comment"> * The identification happens by global&#39;s name, so we need to keep</span></div><div class="line"><span class="comment"> * track what names we bound.</span></div><div class="line"><span class="comment"> * (not implemented)</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">registry_handle_global_remove(<span class="keyword">struct</span> wthp_registry *wthp_registry,</div><div class="line">                              uint32_t name)</div><div class="line">{</div><div class="line">        printf(<span class="stringliteral">&quot;global %d removed\n&quot;</span>, name);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a name="_a2"></a><a class="code" href="structwthp__registry__listener.html">wthp_registry_listener</a> registry_listener = {</div><div class="line">        registry_handle_global,</div><div class="line">        registry_handle_global_remove</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">int</span></div><div class="line">watch_ctl(<span class="keyword">struct</span> watch *w, <span class="keywordtype">int</span> op, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>epoll_event ee;</div><div class="line"></div><div class="line">        ee.events = events;</div><div class="line">        ee.data.ptr = w;</div><div class="line">        <span class="keywordflow">return</span> epoll_ctl(w-&gt;display-&gt;epoll_fd, op, w-&gt;fd, &amp;ee);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">wtimer_handle_data(<span class="keyword">struct</span> watch *w, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>wtimer *t = container_of(w, <span class="keyword">struct</span> wtimer, watch);</div><div class="line">        uint64_t expires;</div><div class="line">        <span class="keywordtype">int</span> len;</div><div class="line"></div><div class="line">        assert(events &amp; EPOLLIN);</div><div class="line"></div><div class="line">        len = read(t-&gt;watch.fd, &amp;expires, <span class="keyword">sizeof</span> expires);</div><div class="line">        <span class="keywordflow">if</span> (!(len == -1 &amp;&amp; errno == EAGAIN) &amp;&amp; len != <span class="keyword">sizeof</span> expires) {</div><div class="line">                perror(<span class="stringliteral">&quot;timer read&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> t-&gt;func(t, t-&gt;data);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct </span>wtimer *</div><div class="line">wtimer_create(<span class="keyword">struct</span> display *dpy, <span class="keywordtype">int</span> clock_id,</div><div class="line">              <span class="keywordtype">void</span> (*func)(<span class="keyword">struct</span> wtimer *, <span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *data)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>wtimer *t;</div><div class="line"></div><div class="line">        t = zalloc(<span class="keyword">sizeof</span> *t);</div><div class="line">        <span class="keywordflow">if</span> (!t)</div><div class="line">                <span class="keywordflow">return</span> NULL;</div><div class="line"></div><div class="line">        t-&gt;watch.display = dpy;</div><div class="line">        t-&gt;watch.fd = timerfd_create(clock_id, TFD_CLOEXEC);</div><div class="line">        t-&gt;watch.cb = wtimer_handle_data;</div><div class="line">        t-&gt;func = func;</div><div class="line">        t-&gt;data = data;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (t-&gt;watch.fd == -1) {</div><div class="line">                perror(<span class="stringliteral">&quot;wtimer_create: timerfd_create&quot;</span>);</div><div class="line">                <span class="keywordflow">goto</span> out_free;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (watch_ctl(&amp;t-&gt;watch, EPOLL_CTL_ADD, EPOLLIN) &lt; 0) {</div><div class="line">                perror(<span class="stringliteral">&quot;adding timer watch&quot;</span>);</div><div class="line">                <span class="keywordflow">goto</span> out_close;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> t;</div><div class="line"></div><div class="line">out_close:</div><div class="line">        close(t-&gt;watch.fd);</div><div class="line"></div><div class="line">out_free:</div><div class="line">        free(t);</div><div class="line">        <span class="keywordflow">return</span> NULL;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">wtimer_destroy(<span class="keyword">struct</span> wtimer *t)</div><div class="line">{</div><div class="line">        watch_ctl(&amp;t-&gt;watch, EPOLL_CTL_DEL, 0);</div><div class="line">        close(t-&gt;watch.fd);</div><div class="line">        free(t);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">wtimer_arm_once(<span class="keyword">struct</span> wtimer *t, <span class="keywordtype">int</span> ms_delay)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>itimerspec its;</div><div class="line"></div><div class="line">        its.it_interval.tv_sec = 0;</div><div class="line">        its.it_interval.tv_nsec = 0;</div><div class="line">        its.it_value.tv_sec = ms_delay / 1000;</div><div class="line">        its.it_value.tv_nsec = (ms_delay % 1000) * 1000 * 1000;</div><div class="line">        <span class="keywordflow">if</span> (timerfd_settime(t-&gt;watch.fd, 0, &amp;its, NULL) &lt; 0) {</div><div class="line">                perror(<span class="stringliteral">&quot;arming timer&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">connection_handle_data(<span class="keyword">struct</span> watch *w, uint32_t events)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>display *dpy = container_of(w, <span class="keyword">struct</span> display, conn_watch);</div><div class="line">        <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLERR) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Connection errored out.\n&quot;</span>);</div><div class="line">                dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLOUT) {</div><div class="line">                <span class="comment">/* Flush out again. If the flush completes, stop</span></div><div class="line"><span class="comment">                 * polling for writable as everything has been written.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                ret = wth_connection_flush(dpy-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret == 0)</div><div class="line">                        watch_ctl(&amp;dpy-&gt;conn_watch, EPOLL_CTL_MOD, EPOLLIN);</div><div class="line">                <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; errno != EAGAIN)</div><div class="line">                        dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLIN) {</div><div class="line">                <span class="comment">/* Do not ignore EPROTO */</span></div><div class="line">                ret = wth_connection_read(dpy-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">                        perror(<span class="stringliteral">&quot;Connection read error\n&quot;</span>);</div><div class="line">                        dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                        <span class="keywordflow">return</span>;</div><div class="line">                }</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (events &amp; EPOLLHUP) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Connection hung up.\n&quot;</span>);</div><div class="line">                dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">mainloop(<span class="keyword">struct</span> display *dpy)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>epoll_event ee[MAX_EPOLL_WATCHES];</div><div class="line">        <span class="keyword">struct </span>watch *w;</div><div class="line">        <span class="keywordtype">int</span> count;</div><div class="line">        <span class="keywordtype">int</span> i;</div><div class="line">        <span class="keywordtype">int</span> ret;</div><div class="line"></div><div class="line">        dpy-&gt;running = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        <span class="keywordflow">while</span> (1) {</div><div class="line">                <span class="comment">/* Dispatch queued events. */</span></div><div class="line">                ret = wth_connection_dispatch(dpy-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0)</div><div class="line">                        dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (!dpy-&gt;running)</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line"></div><div class="line">                <span class="comment">/* Run any application idle tasks at this point. */</span></div><div class="line">                <span class="comment">/* (nothing to run so far) */</span></div><div class="line"></div><div class="line">                <span class="comment">/* Flush out buffered requests. If the Waltham socket is</span></div><div class="line"><span class="comment">                 * full, poll it for writable too, and continue flushing then.</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                ret = wth_connection_flush(dpy-&gt;connection);</div><div class="line">                <span class="keywordflow">if</span> (ret &lt; 0 &amp;&amp; errno == EAGAIN) {</div><div class="line">                        watch_ctl(&amp;dpy-&gt;conn_watch, EPOLL_CTL_MOD, EPOLLIN | EPOLLOUT);</div><div class="line">                } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ret &lt; 0) {</div><div class="line">                        perror(<span class="stringliteral">&quot;Connection flush failed&quot;</span>);</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Wait for events or signals */</span></div><div class="line">                count = epoll_wait(dpy-&gt;epoll_fd,</div><div class="line">                                   ee, ARRAY_LENGTH(ee), -1);</div><div class="line">                <span class="keywordflow">if</span> (count &lt; 0 &amp;&amp; errno != EINTR) {</div><div class="line">                        perror(<span class="stringliteral">&quot;Error with epoll_wait&quot;</span>);</div><div class="line">                        <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="comment">/* Waltham events only read in the callback, not dispatched,</span></div><div class="line"><span class="comment">                 * if the Waltham socket signalled readable. If it signalled</span></div><div class="line"><span class="comment">                 * writable, flush more. See connection_handle_data().</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keywordflow">for</span> (i = 0; i &lt; count; i++) {</div><div class="line">                        w = ee[i].data.ptr;</div><div class="line">                        w-&gt;cb(w, ee[i].events);</div><div class="line">                }</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">/* A one-off asynchronous open-coded roundtrip handler. */</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">bling_done(<span class="keyword">struct</span> wthp_callback *cb, uint32_t arg)</div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;...sync done.\n&quot;</span>);</div><div class="line"></div><div class="line">        wthp_callback_free(cb);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">struct </span><a name="_a3"></a><a class="code" href="structwthp__callback__listener.html">wthp_callback_listener</a> bling_listener = {</div><div class="line">        bling_done</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">fiddle_timer_cb(<span class="keyword">struct</span> wtimer *t, <span class="keywordtype">void</span> *data)</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>display *dpy = data;</div><div class="line">        <span class="keyword">static</span> <span class="keywordtype">int</span> count;</div><div class="line"></div><div class="line">        fiddle_with_region(dpy);</div><div class="line"></div><div class="line">        count++;</div><div class="line">        <span class="keywordflow">if</span> (count &gt; 4)</div><div class="line">                dpy-&gt;running = <span class="keyword">false</span>;</div><div class="line">        <span class="keywordflow">else</span></div><div class="line">                wtimer_arm_once(t, 1000);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span></div><div class="line">check_connection_errors(<span class="keyword">struct</span> <a class="code" href="classwth__connection.html">wth_connection</a> *conn)</div><div class="line">{</div><div class="line">        <span class="keywordtype">int</span> err;</div><div class="line">        uint32_t id;</div><div class="line">        uint32_t code;</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> *intf;</div><div class="line"></div><div class="line">        err = wth_connection_get_error(conn);</div><div class="line">        <span class="keywordflow">if</span> (err) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Connection error &#39;%s&#39;.\n&quot;</span>, strerror(err));</div><div class="line">                <span class="keywordflow">if</span> (err == EPROTO) {</div><div class="line">                        code = wth_connection_get_protocol_error(conn,</div><div class="line">                                &amp;intf, &amp;<span class="keywordtype">id</span>);</div><div class="line">                        fprintf(stderr,</div><div class="line">                                <span class="stringliteral">&quot;  protocol error was %s@%#x: %d\n&quot;</span>,</div><div class="line">                                intf, <span class="keywordtype">id</span>, code);</div><div class="line">                }</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;No errors recorded.\n&quot;</span>);</div><div class="line">        }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main(<span class="keywordtype">int</span> arcg, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">        <span class="keyword">struct </span>display dpy = { 0 };</div><div class="line"></div><div class="line">        dpy.epoll_fd = epoll_create1(EPOLL_CLOEXEC);</div><div class="line">        <span class="keywordflow">if</span> (dpy.epoll_fd == -1) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error on epoll_create1&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        dpy.fiddle_timer = wtimer_create(&amp;dpy, CLOCK_MONOTONIC,</div><div class="line">                                         fiddle_timer_cb, &amp;dpy);</div><div class="line">        <span class="keywordflow">if</span> (!dpy.fiddle_timer) {</div><div class="line">                perror(<span class="stringliteral">&quot;creating fiddle_timer&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        dpy.connection = wth_connect_to_server(<span class="stringliteral">&quot;localhost&quot;</span>, <span class="stringliteral">&quot;34400&quot;</span>);</div><div class="line">        <span class="keywordflow">if</span> (!dpy.connection) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error connecting&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        dpy.conn_watch.display = &amp;dpy;</div><div class="line">        dpy.conn_watch.cb = connection_handle_data;</div><div class="line">        dpy.conn_watch.fd = wth_connection_get_fd(dpy.connection);</div><div class="line">        <span class="keywordflow">if</span> (watch_ctl(&amp;dpy.conn_watch, EPOLL_CTL_ADD, EPOLLIN) &lt; 0) {</div><div class="line">                perror(<span class="stringliteral">&quot;Error setting up connection polling&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="comment">/* Create a registry so that we will get advertisements of the</span></div><div class="line"><span class="comment">         * interfaces implemented by the server.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        dpy.registry = wth_connection_create_registry(dpy.connection);</div><div class="line">        wthp_registry_set_listener(dpy.registry, &amp;registry_listener, &amp;dpy);</div><div class="line"></div><div class="line">        <span class="comment">/* Roundtrip ensures all globals&#39; ads have been received. */</span></div><div class="line">        <span class="keywordflow">if</span> (wth_connection_roundtrip(dpy.connection) &lt; 0) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Roundtrip failed.\n&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (!dpy.compositor) {</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;Did not find wthp_compositor, quitting.\n&quot;</span>);</div><div class="line">                exit(1);</div><div class="line">        }</div><div class="line"></div><div class="line">        fiddle_with_region(&amp;dpy);</div><div class="line"></div><div class="line"><span class="preprocessor">#if 0</span></div><div class="line">        <span class="comment">/* Trigger a protocol error, since the test server does not</span></div><div class="line"><span class="comment">         * implement this.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        wthp_compositor_create_surface(dpy.compositor);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">        <span class="comment">/* A one-off asynchronous roundtrip, just for fun. */</span></div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;sending wth_display.sync...\n&quot;</span>);</div><div class="line">        dpy.bling = wth_connection_sync(dpy.connection);</div><div class="line">        wthp_callback_set_listener(dpy.bling, &amp;bling_listener, &amp;dpy);</div><div class="line"></div><div class="line">        <span class="comment">/* Create surfaces, draw initial content, etc. if you want. */</span></div><div class="line">        wtimer_arm_once(dpy.fiddle_timer, 1000);</div><div class="line"></div><div class="line">        mainloop(&amp;dpy);</div><div class="line"></div><div class="line">        <span class="comment">/* destroy all things */</span></div><div class="line">        wtimer_destroy(dpy.fiddle_timer);</div><div class="line"></div><div class="line">        <span class="comment">/* This sends the request, unlike wthp_registry_free() */</span></div><div class="line">        wthp_registry_destroy(dpy.registry);</div><div class="line"></div><div class="line">        <span class="comment">/* Do the final roundtrip to guarantee the server has received</span></div><div class="line"><span class="comment">         * all our tear-down requests.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        wth_connection_roundtrip(dpy.connection);</div><div class="line"></div><div class="line">        <span class="comment">/* Check and report any errors */</span></div><div class="line">        check_connection_errors(dpy.connection);</div><div class="line"></div><div class="line">        <span class="comment">/* Disconnect, automatically destroys wth_display, free</span></div><div class="line"><span class="comment">         * the connection.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        wth_connection_destroy(dpy.connection);</div><div class="line"></div><div class="line">        close(dpy.epoll_fd);</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
