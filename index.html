<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Waltham: Waltham IPC Library</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Waltham
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Waltham IPC Library </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://github.com/waltham/waltham">Waltham</a> is a network IPC library designed to resemble <a href="https://wayland.freedesktop.org/">Wayland</a> both protocol and protocol-API wise. Protocol is described in XML files. A generator translates XML into C code at build time. One designs Waltham protocols exactly the same way as Wayland extensions, you just miss the file descriptor argument type.</p>
<p>The protocol framework is designed to be completely asynchronous and object-oriented, just like Wayland. To make synchronous calls one has to write their protocol definition specifically to do that, there is no shortcut offered.</p>
<p>The goal is to have all protocol definitions to be external, so that a <code>libwaltham</code> compiled once can be used by any project with any protocol definition. Waltham itself would carry just the control protocol definition and public interfaces for <code>wthp_callback</code> and <code>wthp_registry</code>, which each user project would implement on their own. User projects will then run the generator and build in the protocol-specific bits of code and API. <em>The implementation is not this far yet, see [TODO](TODO).</em></p>
<p>Waltham does not (yet) support any kind of encryption, so usage in untrusted networks is not advised. Help with securing the communications would be appreciated, starting with planning on how it should be done. In the mean time, secure tunnels are recommended (e.g. <code>ssh</code>).</p>
<p><b>Waltham ABI and API are not yet stable.</b> Breakage will likely occur until Waltham 1.0.0 has been released. You are still welcome to install Waltham and try it in your projects.</p>
<h1>Documentation </h1>
<p>In addition to this README, the project can build API documentation with Doxygen. Build the project as described below, and you should find the documentation in your <code>@top_builddir@/doc/html/index.html</code>. This README is mirrored on the front page. If the documentation does not seem to get built, try passing <code>--enable-doc</code> to <code>./autogen.sh</code> or <code>./configure</code> and see what it complains about.</p>
<p>You can also read a manually updated snapshot of the <a href="https://waltham.github.io/waltham/">Waltham documentation</a>.</p>
<p>Usage guidelines can be found in <a href="https://waltham.github.io/waltham/pages.html">Related pages</a> in the Doxygen-generated documentation.</p>
<h1>Building and testing </h1>
<p>To build: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ./autogen.sh</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ make</div></div><!-- fragment --><p>To test, first start the server: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ./tests/server</div></div><!-- fragment --><p>Then in another terminal, run the client: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ ./tests/client</div></div><!-- fragment --><p>The client runs for about five seconds excercising the protocol and exits automatically. The server can be stopped with <code>ctrl+c</code>.</p>
<p>If you want to run the example server or client under GDB or Valgrind, use e.g. the following: </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;$ libtool --mode=execute gdb ./tests/server</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;$ libtool --mode=execute valgrind -v --leak-check=full --show-reachable=yes --track-origins=yes --num-callers=30 ./tests/server</div></div><!-- fragment --><h1>Design </h1>
<h2>API </h2>
<p>The Waltham API revolves around two fundamental types: <code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code> and <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code>. Both have the same implementation on both server and client side, although the possible operations (functions to call) vary. Once created, both types are tied to being either server or client side instances.</p>
<p><code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code> represents the TCP connection. For a client it represents the connection to a server, for a server it represents one client.</p>
<p><code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code> represents a protocol object. However, usually user code does not handle wth_objects directly, but works with the API generated from XML files which uses opaque pointer types. These opaque pointer types are simply cast to/from <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code> under the hood. For some uncommon operations that the generator does not create wrappers for, you need to cast to <code>(struct <a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a> *)</code> yourself.</p>
<h2>Threading considerations </h2>
<p>Waltham does not carry features to help making threaded programs easier. However, it should be safe if you restrict all manipulations of a <code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code> and all <code>wth_objects</code> associated with it to a single thread at a time.</p>
<h2>Message handling and object lifetimes </h2>
<p>Incoming messages, both on the server and client side, are first stored in a raw data buffer. Messages are dispatched directly from the data buffer. This is different from Wayland, which demarshals messages from its data buffer and puts them into queues before dispatching per queue. The additional queueing in Wayland adds some complexity that Waltham avoids.</p>
<p>Waltham does not include any automatic object destruction when a <code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code> is destroyed. User code must track and destroy all associated <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code>s before destroying the <code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code>. This may seem awkward at first, but it gives the user code the opportunity to destroy <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code>s in any specific order it prefers and without the risk of corrupting lists. Compare this to Wayland, where one has to be able to deal with any arbitrary order of destruction between all <code>wl_resource</code>s, and the destructor path of one <code>wl_resource</code> cannot remove any other destroy listeners that might be on the same destroy listener list as that would lead to list corruption.</p>
<p><code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code> instances are created automatically during dispatch, which means that messages not yet dispatched have not created any entries in the table that maps between object IDs on the wire and <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code> instances. Therefore objects do not need to be cleaned up until the messages creating them have been dispatched, so there is no need for destructor hooks in <code><a class="el" href="classwth__object.html" title="A generic Waltham protocol object representation (a proxy) ">wth_object</a></code>.</p>
<h2>Main loop integration </h2>
<p>Waltham does not have any kind of event loop implementation itself. For every <code><a class="el" href="classwth__connection.html" title="A Waltham connection. ">wth_connection</a></code>, you get a file descriptor you need to watch and then call the appropriate Waltham functions which are guaranteed to never block (unless the user provides message handlers that block).</p>
<p>This design was chosen to ease porting of Waltham to other operating systems and allow users to use any main loop implementations they wish. Even though the examples use Linuxisms like <code>epoll</code> and <code>timerfd</code>, the library does not. This also avoids imposing a dependency to any particular external event loop library. It makes <code>libwaltham</code> a much thinner library than <code>libwayland-server</code>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
